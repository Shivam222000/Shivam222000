### Moore’s Voting Algorithm ###

Intuition: The question clearly states that the nums array has a majority element. Since it has a majority element we can say definitely the count is more than N/2.

Majority element count = N/2 + x;

Minority/Other elements = N/2 – x;

Where x is the number of times it occurs after reaching the minimum value N/2.

Now, we can say that count of minority elements and majority elements are equal up to a certain point of time in the array. So when we traverse through the array we try to keep track of the count of elements and which element we are tracking. Since the majority element appears more than N/2 times, we can say that at some point in array traversal we find the majority element. 

Approach: 

1. Initialize 2 variables: 
    Count –  for tracking the count of element
    Element – for which element we are counting
2. Traverse through nums array.
    1.If Count is 0 then initialize the current traversing integer of array as Element 
    2.If the traversing integer of array and Element are same increase Count by 1
    3.If they are different decrease Count by 1
3.The integer present in Element is the result we are expecting 






### Kadane's Algorithm ###


Solution : 3 Optimal Solution: Kadane’s Algorithm 

Intuition: Basically this problem can be done in linear time complexity with Kadane’s algorithm along with that will also get the subarray which is giving the largest positive-sum. 

Approach: 

-> We will have the following variables in the beginning : 

msf – max so far, meh – max sum ending at ith index, start – to get the starting index of ans’s subarray, end – to get the ending index of ans’s subarray. 

-> Traverse the array from starting and add the ith element to max_end_here(meh) , now we will check that adding the ith element gives greater value than max_so_far(msf) or not , if yes then we will update our msf and also update the starting and ending index(initially starting index is zero) . 

for(int i=0;i<nums.size();i++){ 
    meh+=nums[i]; 

    if(meh>msf){ msf=meh; start=s; end=i; } 

    if(meh<0){meh=0; s=i+1;} 
} 
->Now in this step, we will print the answer subarray using the start and end variables.

->Return the largest subarray sum that is:- msf. 






####
Max sum of smallest and second smallest element in any subarray
###

A simple solution is to generate all subarrays, find sum of smallest and second smallest of every subarray. Finally return maximum of all sums.

"""An efficient solution is based on the observation that this problem reduces to finding a maximum sum of two consecutive elements in array.""" 

If (x,y) is the pair ,such that (x+y) is the answer , then x and y must be consecutive elements in the array.

Proof:
        For a subarray with 2 elements , 1st and 2nd smallest elements are those 2 elements.

        Now x and y are present in some subarray such thatthey are the endpoints.

        Now, x, y must be the smallest 2 elements of that subarray. If there are other elements Z1 , Z2, ……., ZK  between x and y, they are greater than or equal to x and y,

Case1 : 
        If there is one element z between x and y , then the smaller subarray with the elements max(x,y) and z , should be the answer , because max(x,y) + z >= x + y
Case2:
        If there are more than one elements between x and y , then the subarray within x and y will have all consecutive elements  (Zi + Zi+1) >= (x+y),  so (x,y) pair can’t be the answer. 
        So, by contradictions, x and y must be consecutive elements in the array.





### Next_permutation ###  

Intuition lies behind the lexicographical ordering of all possible permutations of a given array. There will always be an increasing sequence of all possible permutations when observed.

Let’s check all sequences of permutations of {1,2,3}.

{1,2,3} 

{1,3,2}

{2,1,3}

{2,3,1}

{3,1,2}

{3,2,1}

Thus, we can see every sequence has increasing order. Hence, our approach aims to get a peak from where the increasing sequence starts. This is what we achieve from our first step of the approach. 

Then, we need to get just a larger value than the point where the peak occurs. To make rank as few as possible but greater than input array, just perverse array from breakpoint achieved from the first step of the approach. We achieve these from all remaining steps of our approach.

Approach :

Step 1: Linearly traverse array from backward such that ith index value of the array is less than (i+1)th index value. Store that index in a variable.

Step 2: If the index value received from step 1 is less than 0. This means the given input array is the largest lexicographical permutation. Hence, we will reverse the input array to get the minimum or starting permutation. Linearly traverse array from backward. Find an index that has a value greater than the previously found index. Store index is another variable.

Step 3: Swap values present in indices found in the above two steps.

Step 4: Reverse array from index+1 where the index is found at step 1 till the end of the array.

